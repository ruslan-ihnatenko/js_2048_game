{"mappings":"ACEA,MAAM,EAAO,ICFb,MAME,YACE,EAAe,CACb,CAAC,EAAG,EAAG,EAAG,EAAE,CACZ,CAAC,EAAG,EAAG,EAAG,EAAE,CACZ,CAAC,EAAG,EAAG,EAAG,EAAE,CACZ,CAAC,EAAG,EAAG,EAAG,EAAE,CACb,CACD,CACA,IAAI,CAAC,KAAK,CAAG,EACb,IAAI,CAAC,KAAK,CAAG,EACb,IAAI,CAAC,MAAM,CAAG,MAChB,CAKA,OAAQ,CACN,IAAI,CAAC,MAAM,CAAG,UACd,IAAI,CAAC,aAAa,GAClB,IAAI,CAAC,aAAa,EACpB,CAKA,SAAU,CACR,IAAI,CAAC,KAAK,CAAG,CACX,CAAC,EAAG,EAAG,EAAG,EAAE,CACZ,CAAC,EAAG,EAAG,EAAG,EAAE,CACZ,CAAC,EAAG,EAAG,EAAG,EAAE,CACZ,CAAC,EAAG,EAAG,EAAG,EAAE,CACb,CACD,IAAI,CAAC,KAAK,CAAG,EACb,IAAI,CAAC,MAAM,CAAG,OACd,IAAI,CAAC,KAAK,EACZ,CAMA,UAAW,CACT,OAAO,IAAI,CAAC,KAAK,AACnB,CAMA,UAAW,CACT,OAAO,IAAI,CAAC,KAAK,AACnB,CAMA,WAAY,CACV,OAAO,IAAI,CAAC,MAAM,AACpB,CAKA,eAAgB,CACd,IAAM,EAAa,EAAE,CAGrB,IAAK,IAAI,EAAM,EAAG,EAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAE,IACzC,IAAK,IAAI,EAAM,EAAG,EAAM,IAAI,CAAC,KAAK,CAAC,EAAI,CAAC,MAAM,CAAE,IACjB,IAAzB,IAAI,CAAC,KAAK,CAAC,EAAI,CAAC,EAAI,EACtB,EAAW,IAAI,CAAC,CAAC,EAAK,EAAI,EAKhC,GAAI,EAAW,MAAM,CAAG,EAAG,CACzB,GAAM,CAAC,EAAK,EAAI,CACd,CAAU,CAAC,KAAK,KAAK,CAAC,KAAK,MAAM,GAAK,EAAW,MAAM,EAAE,AAE3D,CAAA,IAAI,CAAC,KAAK,CAAC,EAAI,CAAC,EAAI,CAAG,AAAgB,GAAhB,KAAK,MAAM,GAAW,EAAI,CACnD,CACF,CAKA,UAAW,CACT,IAAI,EAAQ,CAAA,EAEZ,IAAK,IAAI,EAAM,EAAG,EAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAE,IAAO,CAChD,IAAM,EAAS,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,KAAK,CAAC,EAAI,EAE7C,EAAO,QAAQ,KAAO,IAAI,CAAC,KAAK,CAAC,EAAI,CAAC,QAAQ,KAChD,EAAQ,CAAA,EACR,IAAI,CAAC,KAAK,CAAC,EAAI,CAAG,EAEtB,CAMA,OAJI,GACF,IAAI,CAAC,aAAa,GAGb,CACT,CAKA,WAAY,CACV,IAAI,EAAQ,CAAA,EAEZ,IAAK,IAAI,EAAM,EAAG,EAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAE,IAAO,CAChD,IAAM,EAAc,IAAI,IAAI,CAAC,KAAK,CAAC,EAAI,CAAC,CAAC,OAAO,GAC1C,EAAS,IAAI,CAAC,aAAa,CAAC,GAAa,OAAO,GAElD,EAAO,QAAQ,KAAO,IAAI,CAAC,KAAK,CAAC,EAAI,CAAC,QAAQ,KAChD,EAAQ,CAAA,EACR,IAAI,CAAC,KAAK,CAAC,EAAI,CAAG,EAEtB,CAMA,OAJI,GACF,IAAI,CAAC,aAAa,GAGb,CACT,CAKA,QAAS,CACP,IAAI,EAAQ,CAAA,EAEZ,IAAK,IAAI,EAAM,EAAG,EAAM,EAAG,IAAO,CAChC,IAAM,EAAS,CACb,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAI,CAClB,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAI,CAClB,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAI,CAClB,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAI,CACnB,CACK,EAAY,IAAI,CAAC,aAAa,CAAC,GAErC,IAAK,IAAI,EAAM,EAAG,EAAM,EAAG,IACrB,IAAI,CAAC,KAAK,CAAC,EAAI,CAAC,EAAI,GAAK,CAAS,CAAC,EAAI,GACzC,EAAQ,CAAA,EACR,IAAI,CAAC,KAAK,CAAC,EAAI,CAAC,EAAI,CAAG,CAAS,CAAC,EAAI,CAG3C,CAMA,OAJI,GACF,IAAI,CAAC,aAAa,GAGb,CACT,CAKA,UAAW,CACT,IAAI,EAAQ,CAAA,EAEZ,IAAK,IAAI,EAAM,EAAG,EAAM,EAAG,IAAO,CAChC,IAAM,EAAS,CACb,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAI,CAClB,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAI,CAClB,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAI,CAClB,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAI,CACnB,CAAC,OAAO,GACH,EAAY,IAAI,CAAC,aAAa,CAAC,GAAQ,OAAO,GAEpD,IAAK,IAAI,EAAM,EAAG,EAAM,EAAG,IACrB,IAAI,CAAC,KAAK,CAAC,EAAI,CAAC,EAAI,GAAK,CAAS,CAAC,EAAI,GACzC,EAAQ,CAAA,EACR,IAAI,CAAC,KAAK,CAAC,EAAI,CAAC,EAAI,CAAG,CAAS,CAAC,EAAI,CAG3C,CAMA,OAJI,GACF,IAAI,CAAC,aAAa,GAGb,CACT,CAOA,cAAc,CAAK,CAAE,CAEnB,IAAM,EAAW,EAAM,MAAM,CAAC,AAAC,GAAS,AAAS,IAAT,GAExC,IAAK,IAAI,EAAI,EAAG,EAAI,EAAS,MAAM,CAAG,EAAG,IACnC,CAAQ,CAAC,EAAE,GAAK,CAAQ,CAAC,EAAI,EAAE,GACjC,CAAQ,CAAC,EAAE,EAAI,EACf,IAAI,CAAC,KAAK,EAAI,CAAQ,CAAC,EAAE,CACzB,CAAQ,CAAC,EAAI,EAAE,CAAG,GAKtB,IAAM,EAAS,EAAS,MAAM,CAAC,AAAC,GAAS,AAAS,IAAT,GACnC,EAAU,AAAI,MAAM,EAAI,EAAO,MAAM,EAAE,IAAI,CAAC,GAElD,OAAO,EAAO,MAAM,CAAC,EACvB,CAMA,eAAgB,CAEd,IAAK,IAAI,EAAM,EAAG,EAAM,EAAG,IACzB,IAAK,IAAI,EAAM,EAAG,EAAM,EAAG,IACzB,GAA6B,IAAzB,IAAI,CAAC,KAAK,CAAC,EAAI,CAAC,EAAI,EAKpB,EAAM,GAAK,IAAI,CAAC,KAAK,CAAC,EAAI,CAAC,EAAI,GAAK,IAAI,CAAC,KAAK,CAAC,EAAI,CAAC,EAAM,EAAE,EAI5D,EAAM,GAAK,IAAI,CAAC,KAAK,CAAC,EAAI,CAAC,EAAI,GAAK,IAAI,CAAC,KAAK,CAAC,EAAM,EAAE,CAAC,EAAI,CAR9D,MAAO,CAAA,EAeb,OAFA,IAAI,CAAC,MAAM,CAAG,OAEP,CAAA,CACT,CAKA,mBAAoB,CAClB,IAAK,IAAI,EAAM,EAAG,EAAM,EAAG,IACzB,IAAK,IAAI,EAAM,EAAG,EAAM,EAAG,IACzB,GAAI,AAAyB,OAAzB,IAAI,CAAC,KAAK,CAAC,EAAI,CAAC,EAAI,CAGtB,OAFA,IAAI,CAAC,MAAM,CAAG,MAEP,CAAA,EAKb,MAAO,CAAA,CACT,CACF,EDjQM,EAAY,SAAS,aAAa,CAAC,eACnC,EAAe,SAAS,aAAa,CAAC,eACtC,EAAc,SAAS,aAAa,CAAC,UACrC,EAAmB,SAAS,aAAa,CAAC,sBAGhD,IAAI,EAAc,EACd,EAAc,EACd,EAAY,EACZ,EAAY,EAmDhB,SAAS,IACP,IAEI,EAAK,iBAAiB,GACxB,EAAY,kCAAyB,OAC5B,EAAK,aAAa,IAC3B,EAAY,4CAAmC,OAEnD,CA0BA,SAAS,IACP,IAAM,EAAQ,EAAK,QAAQ,GACrB,EAAO,EAAU,gBAAgB,CAAC,cAExC,EAAM,OAAO,CAAC,CAAC,EAAK,KAClB,IAAM,EAAQ,CAAI,CAAC,EAAS,CAAC,gBAAgB,CAAC,eAE9C,EAAI,OAAO,CAAC,CAAC,EAAW,KACtB,IAAM,EAAO,CAAK,CAAC,EAAS,AAE5B,CAAA,EAAK,WAAW,CAAG,AAAc,IAAd,EAAkB,EAAY,GAUrD,AAToB,EASf,SAAS,CAAG,aAEH,IAXY,GAYxB,AAZkB,EAYb,SAAS,CAAC,GAAG,CAAC,CAAC,YAAY,EAZR,EAYgB,CAAC,CAXzC,EACF,GAEA,EAAa,WAAW,CAAG,EAAK,QAAQ,EAC1C,CAoBA,SAAS,EAAY,CAAI,CAAE,CAAI,EAC7B,EACG,gBAAgB,CAAC,YACjB,OAAO,CAAC,AAAC,GAAQ,EAAI,SAAS,CAAC,GAAG,CAAC,WAEtC,IAAM,EAAiB,EAAiB,aAAa,CAAC,CAAC,SAAS,EAAE,EAAK,CAAC,CAExE,CAAA,EAAe,WAAW,CAAG,EAC7B,EAAe,SAAS,CAAC,MAAM,CAAC,SAClC,CA/HA,SAAS,gBAAgB,CAAC,aAAc,AAAC,IACvC,EAAc,EAAM,OAAO,CAAC,EAAE,CAAC,OAAO,CACtC,EAAc,EAAM,OAAO,CAAC,EAAE,CAAC,OAAO,AACxC,GAGA,SAAS,gBAAgB,CAAC,YAAa,AAAC,IACtC,EAAY,EAAM,OAAO,CAAC,EAAE,CAAC,OAAO,CACpC,EAAY,EAAM,OAAO,CAAC,EAAE,CAAC,OAAO,AACtC,GAEA,SAAS,gBAAgB,CAAC,WAAY,KACpC,AAgDF,CAAA,WACE,IAAM,EAAS,EAAY,EACrB,EAAS,EAAY,CAEvB,CAAA,KAAK,GAAG,CAAC,GAAU,KAAK,GAAG,CAAC,GAC1B,EAAS,EACX,EAAK,SAAS,GAEd,EAAK,QAAQ,GAGX,EAAS,EACX,EAAK,QAAQ,GAEb,EAAK,MAAM,GAIf,GACF,CAAA,GAlEA,GAGA,EAAY,gBAAgB,CAAC,QAAS,KACpC,EAAK,OAAO,GACZ,IACA,EAAY,2BAA4B,SA2FR,UAA5B,EAAY,WAAW,GACzB,EAAY,WAAW,CAAG,UAC1B,EAAY,SAAS,CAAC,GAAG,CAAC,WAC1B,EAAY,SAAS,CAAC,MAAM,CAAC,SA5FjC,GAIA,SAAS,gBAAgB,CAAC,UAAW,AAAC,IACpC,IAAI,EAAQ,CAAA,EAEZ,OAAQ,EAAM,GAAG,EACf,IAAK,YACH,EAAQ,EAAK,QAAQ,GACrB,KACF,KAAK,aACH,EAAQ,EAAK,SAAS,GACtB,KACF,KAAK,UACH,EAAQ,EAAK,MAAM,GACnB,KACF,KAAK,YACH,EAAQ,EAAK,QAAQ,EAEzB,CAEI,GACF,GAEJ","sources":["<anon>","src/scripts/main.js","src/modules/Game.class.js"],"sourcesContent":["var $a5fd07fa01589658$exports = {};\nclass $a5fd07fa01589658$var$Game {\n    /**\n   * Creates a new game instance.\n   * @param {number[][]} initialState The initial state of the board.\n   * Default: 4x4 grid filled with zeros.\n   */ constructor(initialState = [\n        [\n            0,\n            0,\n            0,\n            0\n        ],\n        [\n            0,\n            0,\n            0,\n            0\n        ],\n        [\n            0,\n            0,\n            0,\n            0\n        ],\n        [\n            0,\n            0,\n            0,\n            0\n        ]\n    ]){\n        this.score = 0;\n        this.board = initialState;\n        this.status = \"idle\"; // 'idle', 'playing', 'win', 'lose'\n    }\n    /**\n   * Starts the game with initial random tiles.\n   */ start() {\n        this.status = \"playing\";\n        this.addRandomTile();\n        this.addRandomTile();\n    }\n    /**\n   * Resets the game to its initial state.\n   */ restart() {\n        this.board = [\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ]\n        ];\n        this.score = 0;\n        this.status = \"idle\";\n        this.start();\n    }\n    /**\n   * Returns the current score.\n   * @returns {number}\n   */ getScore() {\n        return this.score;\n    }\n    /**\n   * Returns the current state of the board.\n   * @returns {number[][]}\n   */ getState() {\n        return this.board;\n    }\n    /**\n   * Returns the current game status.\n   * @returns {string}\n   */ getStatus() {\n        return this.status;\n    }\n    /**\n   * Adds a random tile (2 or 4) to a random empty cell on the board.\n   */ addRandomTile() {\n        const emptyCells = [];\n        // Collect all empty cells\n        for(let row = 0; row < this.board.length; row++){\n            for(let col = 0; col < this.board[row].length; col++)if (this.board[row][col] === 0) emptyCells.push([\n                row,\n                col\n            ]);\n        }\n        if (emptyCells.length > 0) {\n            const [row, col] = emptyCells[Math.floor(Math.random() * emptyCells.length)];\n            this.board[row][col] = Math.random() < 0.9 ? 2 : 4;\n        }\n    }\n    /**\n   * Slides and merges tiles to the left.\n   */ moveLeft() {\n        let moved = false;\n        for(let row = 0; row < this.board.length; row++){\n            const newRow = this.slideAndMerge(this.board[row]);\n            if (newRow.toString() !== this.board[row].toString()) {\n                moved = true;\n                this.board[row] = newRow;\n            }\n        }\n        if (moved) this.addRandomTile();\n        return moved;\n    }\n    /**\n   * Slides and merges tiles to the right.\n   */ moveRight() {\n        let moved = false;\n        for(let row = 0; row < this.board.length; row++){\n            const reversedRow = [\n                ...this.board[row]\n            ].reverse();\n            const newRow = this.slideAndMerge(reversedRow).reverse();\n            if (newRow.toString() !== this.board[row].toString()) {\n                moved = true;\n                this.board[row] = newRow;\n            }\n        }\n        if (moved) this.addRandomTile();\n        return moved;\n    }\n    /**\n   * Slides and merges tiles upward.\n   */ moveUp() {\n        let moved = false;\n        for(let col = 0; col < 4; col++){\n            const column = [\n                this.board[0][col],\n                this.board[1][col],\n                this.board[2][col],\n                this.board[3][col]\n            ];\n            const newColumn = this.slideAndMerge(column);\n            for(let row = 0; row < 4; row++)if (this.board[row][col] !== newColumn[row]) {\n                moved = true;\n                this.board[row][col] = newColumn[row];\n            }\n        }\n        if (moved) this.addRandomTile();\n        return moved;\n    }\n    /**\n   * Slides and merges tiles downward.\n   */ moveDown() {\n        let moved = false;\n        for(let col = 0; col < 4; col++){\n            const column = [\n                this.board[0][col],\n                this.board[1][col],\n                this.board[2][col],\n                this.board[3][col]\n            ].reverse();\n            const newColumn = this.slideAndMerge(column).reverse();\n            for(let row = 0; row < 4; row++)if (this.board[row][col] !== newColumn[row]) {\n                moved = true;\n                this.board[row][col] = newColumn[row];\n            }\n        }\n        if (moved) this.addRandomTile();\n        return moved;\n    }\n    /**\n   * Slides and merges a row or column of tiles.\n   * @param {number[]} tiles The row or column to slide and merge.\n   * @returns {number[]} The new row or column after sliding and merging.\n   */ slideAndMerge(tiles) {\n        // Filter out zeros and merge tiles\n        const filtered = tiles.filter((tile)=>tile !== 0);\n        for(let i = 0; i < filtered.length - 1; i++)if (filtered[i] === filtered[i + 1]) {\n            filtered[i] *= 2;\n            this.score += filtered[i];\n            filtered[i + 1] = 0;\n        }\n        // Remove zeros again and pad the row/column with zeros\n        const merged = filtered.filter((tile)=>tile !== 0);\n        const padding = new Array(4 - merged.length).fill(0);\n        return merged.concat(padding);\n    }\n    /**\n   * Checks if the game is over (no valid moves).\n   * @returns {boolean}\n   */ checkGameOver() {\n        // Check if there are any empty cells\n        for(let row = 0; row < 4; row++)for(let col = 0; col < 4; col++){\n            if (this.board[row][col] === 0) return false;\n            // Check if adjacent tiles can be merged\n            if (col < 3 && this.board[row][col] === this.board[row][col + 1]) return false;\n            if (row < 3 && this.board[row][col] === this.board[row + 1][col]) return false;\n        }\n        this.status = \"lose\";\n        return true;\n    }\n    /**\n   * Checks if the game is won (a tile with value 2048 exists).\n   */ checkWinCondition() {\n        for(let row = 0; row < 4; row++){\n            for(let col = 0; col < 4; col++)if (this.board[row][col] === 2048) {\n                this.status = \"win\";\n                return true;\n            }\n        }\n        return false;\n    }\n}\n$a5fd07fa01589658$exports = $a5fd07fa01589658$var$Game;\n\n\nconst $09e991522ca7e64e$var$game = new $a5fd07fa01589658$exports();\n// HTML Elements\nconst $09e991522ca7e64e$var$gameField = document.querySelector(\".game-field\");\nconst $09e991522ca7e64e$var$scoreElement = document.querySelector(\".game-score\");\nconst $09e991522ca7e64e$var$startButton = document.querySelector(\".start\");\nconst $09e991522ca7e64e$var$messageContainer = document.querySelector(\".message-container\");\n// Touch Events\nlet $09e991522ca7e64e$var$touchStartX = 0;\nlet $09e991522ca7e64e$var$touchStartY = 0;\nlet $09e991522ca7e64e$var$touchEndX = 0;\nlet $09e991522ca7e64e$var$touchEndY = 0;\n// eslint-disable-next-line no-shadow\ndocument.addEventListener(\"touchstart\", (event)=>{\n    $09e991522ca7e64e$var$touchStartX = event.touches[0].clientX;\n    $09e991522ca7e64e$var$touchStartY = event.touches[0].clientY;\n});\n// eslint-disable-next-line no-shadow\ndocument.addEventListener(\"touchmove\", (event)=>{\n    $09e991522ca7e64e$var$touchEndX = event.touches[0].clientX;\n    $09e991522ca7e64e$var$touchEndY = event.touches[0].clientY;\n});\ndocument.addEventListener(\"touchend\", ()=>{\n    $09e991522ca7e64e$var$handleSwipe();\n});\n/** Starts the game and initializes the board */ $09e991522ca7e64e$var$startButton.addEventListener(\"click\", ()=>{\n    $09e991522ca7e64e$var$game.restart();\n    $09e991522ca7e64e$var$renderBoard();\n    $09e991522ca7e64e$var$showMessage(\"Game started! Good luck!\", \"start\");\n    $09e991522ca7e64e$var$toggleStartButton();\n});\n/** Listen for key events */ // eslint-disable-next-line no-shadow\ndocument.addEventListener(\"keydown\", (event)=>{\n    let moved = false;\n    switch(event.key){\n        case \"ArrowLeft\":\n            moved = $09e991522ca7e64e$var$game.moveLeft();\n            break;\n        case \"ArrowRight\":\n            moved = $09e991522ca7e64e$var$game.moveRight();\n            break;\n        case \"ArrowUp\":\n            moved = $09e991522ca7e64e$var$game.moveUp();\n            break;\n        case \"ArrowDown\":\n            moved = $09e991522ca7e64e$var$game.moveDown();\n            break;\n    }\n    if (moved) $09e991522ca7e64e$var$gameUpdate();\n});\nfunction $09e991522ca7e64e$var$gameUpdate() {\n    $09e991522ca7e64e$var$renderBoard();\n    if ($09e991522ca7e64e$var$game.checkWinCondition()) $09e991522ca7e64e$var$showMessage(\"\\uD83C\\uDF89 You win! Congrats!\", \"win\");\n    else if ($09e991522ca7e64e$var$game.checkGameOver()) $09e991522ca7e64e$var$showMessage(\"\\uD83D\\uDC80 Game Over! Restart the game?\", \"lose\");\n}\n// Swipe Events\nfunction $09e991522ca7e64e$var$handleSwipe() {\n    const deltaX = $09e991522ca7e64e$var$touchEndX - $09e991522ca7e64e$var$touchStartX;\n    const deltaY = $09e991522ca7e64e$var$touchEndY - $09e991522ca7e64e$var$touchStartY;\n    if (Math.abs(deltaX) > Math.abs(deltaY)) {\n        if (deltaX > 0) $09e991522ca7e64e$var$game.moveRight();\n        else $09e991522ca7e64e$var$game.moveLeft();\n    } else if (deltaY > 0) $09e991522ca7e64e$var$game.moveDown();\n    else $09e991522ca7e64e$var$game.moveUp();\n    $09e991522ca7e64e$var$gameUpdate();\n}\n/** Renders the game board based on the current state */ function $09e991522ca7e64e$var$renderBoard() {\n    const state = $09e991522ca7e64e$var$game.getState();\n    const rows = $09e991522ca7e64e$var$gameField.querySelectorAll(\".field-row\");\n    state.forEach((row, rowIndex)=>{\n        const cells = rows[rowIndex].querySelectorAll(\".field-cell\");\n        row.forEach((cellValue, colIndex)=>{\n            const cell = cells[colIndex];\n            cell.textContent = cellValue !== 0 ? cellValue : \"\";\n            $09e991522ca7e64e$var$updateCellStyle(cell, cellValue);\n        });\n    });\n    $09e991522ca7e64e$var$scoreElement.textContent = $09e991522ca7e64e$var$game.getScore();\n}\n/** Updates the cell style based on its value */ function $09e991522ca7e64e$var$updateCellStyle(cell, value) {\n    cell.className = \"field-cell\"; // Reset class\n    if (value !== 0) cell.classList.add(`field-cell--${value}`); // Apply dynamic class\n}\nfunction $09e991522ca7e64e$var$toggleStartButton() {\n    if ($09e991522ca7e64e$var$startButton.textContent === \"Start\") {\n        $09e991522ca7e64e$var$startButton.textContent = \"Restart\";\n        $09e991522ca7e64e$var$startButton.classList.add(\"restart\");\n        $09e991522ca7e64e$var$startButton.classList.remove(\"start\");\n    }\n}\n/** Shows the appropriate message based on game status */ function $09e991522ca7e64e$var$showMessage(text, type) {\n    $09e991522ca7e64e$var$messageContainer.querySelectorAll(\".message\").forEach((msg)=>msg.classList.add(\"hidden\"));\n    const messageElement = $09e991522ca7e64e$var$messageContainer.querySelector(`.message-${type}`);\n    messageElement.textContent = text;\n    messageElement.classList.remove(\"hidden\");\n}\n\n\n//# sourceMappingURL=index.e8ad32b0.js.map\n","const Game = require('../modules/Game.class.js');\n\nconst game = new Game();\n\n// HTML Elements\nconst gameField = document.querySelector('.game-field');\nconst scoreElement = document.querySelector('.game-score');\nconst startButton = document.querySelector('.start');\nconst messageContainer = document.querySelector('.message-container');\n\n// Touch Events\nlet touchStartX = 0;\nlet touchStartY = 0;\nlet touchEndX = 0;\nlet touchEndY = 0;\n\n// eslint-disable-next-line no-shadow\ndocument.addEventListener('touchstart', (event) => {\n  touchStartX = event.touches[0].clientX;\n  touchStartY = event.touches[0].clientY;\n});\n\n// eslint-disable-next-line no-shadow\ndocument.addEventListener('touchmove', (event) => {\n  touchEndX = event.touches[0].clientX;\n  touchEndY = event.touches[0].clientY;\n});\n\ndocument.addEventListener('touchend', () => {\n  handleSwipe();\n});\n\n/** Starts the game and initializes the board */\nstartButton.addEventListener('click', () => {\n  game.restart();\n  renderBoard();\n  showMessage('Game started! Good luck!', 'start');\n  toggleStartButton();\n});\n\n/** Listen for key events */\n// eslint-disable-next-line no-shadow\ndocument.addEventListener('keydown', (event) => {\n  let moved = false;\n\n  switch (event.key) {\n    case 'ArrowLeft':\n      moved = game.moveLeft();\n      break;\n    case 'ArrowRight':\n      moved = game.moveRight();\n      break;\n    case 'ArrowUp':\n      moved = game.moveUp();\n      break;\n    case 'ArrowDown':\n      moved = game.moveDown();\n      break;\n  }\n\n  if (moved) {\n    gameUpdate();\n  }\n});\n\nfunction gameUpdate() {\n  renderBoard();\n\n  if (game.checkWinCondition()) {\n    showMessage('🎉 You win! Congrats!', 'win');\n  } else if (game.checkGameOver()) {\n    showMessage('💀 Game Over! Restart the game?', 'lose');\n  }\n}\n\n// Swipe Events\n\nfunction handleSwipe() {\n  const deltaX = touchEndX - touchStartX;\n  const deltaY = touchEndY - touchStartY;\n\n  if (Math.abs(deltaX) > Math.abs(deltaY)) {\n    if (deltaX > 0) {\n      game.moveRight();\n    } else {\n      game.moveLeft();\n    }\n  } else {\n    if (deltaY > 0) {\n      game.moveDown();\n    } else {\n      game.moveUp();\n    }\n  }\n\n  gameUpdate();\n}\n\n/** Renders the game board based on the current state */\nfunction renderBoard() {\n  const state = game.getState();\n  const rows = gameField.querySelectorAll('.field-row');\n\n  state.forEach((row, rowIndex) => {\n    const cells = rows[rowIndex].querySelectorAll('.field-cell');\n\n    row.forEach((cellValue, colIndex) => {\n      const cell = cells[colIndex];\n\n      cell.textContent = cellValue !== 0 ? cellValue : '';\n      updateCellStyle(cell, cellValue);\n    });\n  });\n\n  scoreElement.textContent = game.getScore();\n}\n\n/** Updates the cell style based on its value */\nfunction updateCellStyle(cell, value) {\n  cell.className = 'field-cell'; // Reset class\n\n  if (value !== 0) {\n    cell.classList.add(`field-cell--${value}`); // Apply dynamic class\n  }\n}\n\nfunction toggleStartButton() {\n  if (startButton.textContent === 'Start') {\n    startButton.textContent = 'Restart';\n    startButton.classList.add('restart');\n    startButton.classList.remove('start');\n  }\n}\n\n/** Shows the appropriate message based on game status */\nfunction showMessage(text, type) {\n  messageContainer\n    .querySelectorAll('.message')\n    .forEach((msg) => msg.classList.add('hidden'));\n\n  const messageElement = messageContainer.querySelector(`.message-${type}`);\n\n  messageElement.textContent = text;\n  messageElement.classList.remove('hidden');\n}\n","class Game {\n  /**\n   * Creates a new game instance.\n   * @param {number[][]} initialState The initial state of the board.\n   * Default: 4x4 grid filled with zeros.\n   */\n  constructor(\n    initialState = [\n      [0, 0, 0, 0],\n      [0, 0, 0, 0],\n      [0, 0, 0, 0],\n      [0, 0, 0, 0],\n    ],\n  ) {\n    this.score = 0;\n    this.board = initialState;\n    this.status = 'idle'; // 'idle', 'playing', 'win', 'lose'\n  }\n\n  /**\n   * Starts the game with initial random tiles.\n   */\n  start() {\n    this.status = 'playing';\n    this.addRandomTile();\n    this.addRandomTile();\n  }\n\n  /**\n   * Resets the game to its initial state.\n   */\n  restart() {\n    this.board = [\n      [0, 0, 0, 0],\n      [0, 0, 0, 0],\n      [0, 0, 0, 0],\n      [0, 0, 0, 0],\n    ];\n    this.score = 0;\n    this.status = 'idle';\n    this.start();\n  }\n\n  /**\n   * Returns the current score.\n   * @returns {number}\n   */\n  getScore() {\n    return this.score;\n  }\n\n  /**\n   * Returns the current state of the board.\n   * @returns {number[][]}\n   */\n  getState() {\n    return this.board;\n  }\n\n  /**\n   * Returns the current game status.\n   * @returns {string}\n   */\n  getStatus() {\n    return this.status;\n  }\n\n  /**\n   * Adds a random tile (2 or 4) to a random empty cell on the board.\n   */\n  addRandomTile() {\n    const emptyCells = [];\n\n    // Collect all empty cells\n    for (let row = 0; row < this.board.length; row++) {\n      for (let col = 0; col < this.board[row].length; col++) {\n        if (this.board[row][col] === 0) {\n          emptyCells.push([row, col]);\n        }\n      }\n    }\n\n    if (emptyCells.length > 0) {\n      const [row, col] =\n        emptyCells[Math.floor(Math.random() * emptyCells.length)];\n\n      this.board[row][col] = Math.random() < 0.9 ? 2 : 4;\n    }\n  }\n\n  /**\n   * Slides and merges tiles to the left.\n   */\n  moveLeft() {\n    let moved = false;\n\n    for (let row = 0; row < this.board.length; row++) {\n      const newRow = this.slideAndMerge(this.board[row]);\n\n      if (newRow.toString() !== this.board[row].toString()) {\n        moved = true;\n        this.board[row] = newRow;\n      }\n    }\n\n    if (moved) {\n      this.addRandomTile();\n    }\n\n    return moved;\n  }\n\n  /**\n   * Slides and merges tiles to the right.\n   */\n  moveRight() {\n    let moved = false;\n\n    for (let row = 0; row < this.board.length; row++) {\n      const reversedRow = [...this.board[row]].reverse();\n      const newRow = this.slideAndMerge(reversedRow).reverse();\n\n      if (newRow.toString() !== this.board[row].toString()) {\n        moved = true;\n        this.board[row] = newRow;\n      }\n    }\n\n    if (moved) {\n      this.addRandomTile();\n    }\n\n    return moved;\n  }\n\n  /**\n   * Slides and merges tiles upward.\n   */\n  moveUp() {\n    let moved = false;\n\n    for (let col = 0; col < 4; col++) {\n      const column = [\n        this.board[0][col],\n        this.board[1][col],\n        this.board[2][col],\n        this.board[3][col],\n      ];\n      const newColumn = this.slideAndMerge(column);\n\n      for (let row = 0; row < 4; row++) {\n        if (this.board[row][col] !== newColumn[row]) {\n          moved = true;\n          this.board[row][col] = newColumn[row];\n        }\n      }\n    }\n\n    if (moved) {\n      this.addRandomTile();\n    }\n\n    return moved;\n  }\n\n  /**\n   * Slides and merges tiles downward.\n   */\n  moveDown() {\n    let moved = false;\n\n    for (let col = 0; col < 4; col++) {\n      const column = [\n        this.board[0][col],\n        this.board[1][col],\n        this.board[2][col],\n        this.board[3][col],\n      ].reverse();\n      const newColumn = this.slideAndMerge(column).reverse();\n\n      for (let row = 0; row < 4; row++) {\n        if (this.board[row][col] !== newColumn[row]) {\n          moved = true;\n          this.board[row][col] = newColumn[row];\n        }\n      }\n    }\n\n    if (moved) {\n      this.addRandomTile();\n    }\n\n    return moved;\n  }\n\n  /**\n   * Slides and merges a row or column of tiles.\n   * @param {number[]} tiles The row or column to slide and merge.\n   * @returns {number[]} The new row or column after sliding and merging.\n   */\n  slideAndMerge(tiles) {\n    // Filter out zeros and merge tiles\n    const filtered = tiles.filter((tile) => tile !== 0);\n\n    for (let i = 0; i < filtered.length - 1; i++) {\n      if (filtered[i] === filtered[i + 1]) {\n        filtered[i] *= 2;\n        this.score += filtered[i];\n        filtered[i + 1] = 0;\n      }\n    }\n\n    // Remove zeros again and pad the row/column with zeros\n    const merged = filtered.filter((tile) => tile !== 0);\n    const padding = new Array(4 - merged.length).fill(0);\n\n    return merged.concat(padding);\n  }\n\n  /**\n   * Checks if the game is over (no valid moves).\n   * @returns {boolean}\n   */\n  checkGameOver() {\n    // Check if there are any empty cells\n    for (let row = 0; row < 4; row++) {\n      for (let col = 0; col < 4; col++) {\n        if (this.board[row][col] === 0) {\n          return false;\n        }\n\n        // Check if adjacent tiles can be merged\n        if (col < 3 && this.board[row][col] === this.board[row][col + 1]) {\n          return false;\n        }\n\n        if (row < 3 && this.board[row][col] === this.board[row + 1][col]) {\n          return false;\n        }\n      }\n    }\n    this.status = 'lose';\n\n    return true;\n  }\n\n  /**\n   * Checks if the game is won (a tile with value 2048 exists).\n   */\n  checkWinCondition() {\n    for (let row = 0; row < 4; row++) {\n      for (let col = 0; col < 4; col++) {\n        if (this.board[row][col] === 2048) {\n          this.status = 'win';\n\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n}\n\nmodule.exports = Game;\n"],"names":["$09e991522ca7e64e$var$game","constructor","initialState","score","board","status","start","addRandomTile","restart","getScore","getState","getStatus","emptyCells","row","length","col","push","Math","floor","random","moveLeft","moved","newRow","slideAndMerge","toString","moveRight","reversedRow","reverse","moveUp","column","newColumn","moveDown","tiles","filtered","filter","tile","i","merged","padding","Array","fill","concat","checkGameOver","checkWinCondition","$09e991522ca7e64e$var$gameField","document","querySelector","$09e991522ca7e64e$var$scoreElement","$09e991522ca7e64e$var$startButton","$09e991522ca7e64e$var$messageContainer","$09e991522ca7e64e$var$touchStartX","$09e991522ca7e64e$var$touchStartY","$09e991522ca7e64e$var$touchEndX","$09e991522ca7e64e$var$touchEndY","$09e991522ca7e64e$var$gameUpdate","$09e991522ca7e64e$var$renderBoard","$09e991522ca7e64e$var$showMessage","state","rows","querySelectorAll","forEach","rowIndex","cells","cellValue","colIndex","cell","textContent","className","classList","add","text","type","msg","messageElement","remove","addEventListener","event","touches","clientX","clientY","$09e991522ca7e64e$var$handleSwipe","deltaX","deltaY","abs","key"],"version":3,"file":"index.e8ad32b0.js.map"}